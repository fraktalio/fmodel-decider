// Re-export all components from their individual files
export { restaurantDecider } from "./restaurantDecider.ts";
export { restaurantView } from "./restaurantView.ts";
export { orderDecider } from "./orderDecider.ts";
export { orderView } from "./orderView.ts";
export { restaurantOrderWorkflow } from "./restaurantOrderWorkflow.ts";

// Import for combined exports
import { restaurantDecider } from "./restaurantDecider.ts";
import { orderDecider } from "./orderDecider.ts";
import { restaurantView } from "./restaurantView.ts";
import { orderView } from "./orderView.ts";
import { restaurantOrderWorkflow } from "./restaurantOrderWorkflow.ts";
import type { OrderTaskName } from "./restaurantOrderWorkflow.ts";
import type {
  Command,
  Event,
  Order,
  OrderView,
  Restaurant,
  RestaurantView,
} from "./api.ts";
import type { IAggregateDecider } from "../../decider.ts";
import type { IProjection } from "../../view.ts";
import type { IAggregateWorkflowProcess } from "../../process_workflow.ts";

// Re-export types
export type { Order, OrderView, Restaurant, RestaurantView } from "./api.ts";

/**
 * Combined decider that handles all restaurant and order operations
 *
 * @remarks
 * This combines the restaurant and order deciders using tuple-based composition.
 * The resulting decider can handle all command types and maintains separate state for each aggregate.
 *
 * State structure: readonly [Restaurant | null, Order | null]
 */
export const all_domain_deciders: IAggregateDecider<
  Command,
  readonly [Restaurant | null, Order | null],
  Event
> = restaurantDecider.combineViaTuples(orderDecider);

/**
 * Combined domain view that handles all events
 *
 * @remarks
 * This combines all four views/slices into a single unified view:
 * - restaurantView: Handles RestaurantCreatedEvent and RestaurantMenuChangedEvent
 * - orderView: Handles RestaurantOrderPlacedEvent and OrderPreparedEvent
 *
 * The combined view uses tuple-based state composition to keep each view's state separate.
 * State structure: readonly [readonly [RestaurantViewState, OrderViewState]
 *
 * This demonstrates how multiple independent views can be composed into a single
 * component that handles all domain events.
 */
export const all_domain_views = restaurantView
  .combineViaTuples(orderView);

/**
 * Generic command handler for event-sourced aggregate systems with workflow orchestration
 *
 * @remarks
 * This generic function orchestrates the complete command handling flow with recursive workflow support:
 * 1. Fetches the current event history for the command
 * 2. Uses a decider to compute new events based on command and history
 * 3. For each new event:
 *    a. Retrieves the corresponding view state and projects the event
 *    b. Processes the event through the workflow to generate orchestration commands
 *    c. Recursively feeds workflow commands back into the decider
 *    d. Continues until no more workflow commands are generated
 *
 * The recursive processing ensures that workflow-generated commands (e.g., CreateOrderCommand
 * triggered by RestaurantOrderPlacedEvent) are automatically handled, producing their own events
 * (e.g., OrderCreatedEvent) which may trigger further workflow actions. All events, including
 * those generated by recursive workflow command processing, are accumulated in the returned
 * `newEvents` array.
 *
 * Events are processed sequentially to maintain proper ordering, which is critical in
 * event-sourced systems where the order of events determines the final state.
 *
 * This demonstrates the separation between:
 * - Write-side (deciders producing events)
 * - Read-side (views consuming events)
 * - Orchestration (workflows coordinating across aggregates with recursive command handling)
 *
 * @typeParam C - Command type
 * @typeParam S - State type used by the decider
 * @typeParam E - Event type
 * @typeParam VS - View state type
 * @typeParam TaskName - Task name type for workflow state tracking
 *
 * @param command - The command to handle
 * @param currentEvents - Async function that fetches the event history for the command
 * @param currentViewState - Async function that retrieves the view state for a specific event
 * @param decider - The aggregate decider that computes new events from command and history
 * @param view - The view that evolves state from events
 * @param workflow - The workflow process that orchestrates cross-aggregate operations
 *
 * @returns Promise resolving to an object containing:
 * - `newEvents`: All events produced by handling the command, including events from recursively processed workflow commands
 * - `newViewState`: The updated view state after sequentially projecting all events
 *
 * @example
 * ```ts
 * const result = await handleCommandGeneric(
 *   placeOrderCommand,
 *   async (cmd) => await eventStore.getEvents(cmd.id),
 *   async (evt) => await viewStore.getStateForEvent(evt),
 *   restaurantDecider,
 *   restaurantView,
 *   restaurantOrderWorkflow
 * );
 * // result.newEvents: [RestaurantOrderPlacedEvent, OrderCreatedEvent]
 * // All events including workflow-generated ones are in newEvents
 * // result.newViewState: updated view state with both restaurant and order updates
 * ```
 *
 * @author Fraktalio
 */
export const handleCommandGeneric = async <
  C,
  S,
  E,
  VS,
  TaskName extends string = string,
>(
  command: C,
  currentEvents: (cmd: C) => Promise<readonly E[]>,
  currentViewState: (evt: E) => Promise<VS>,
  decider: IAggregateDecider<C, S, E>,
  view: IProjection<VS, E>,
  workflow: IAggregateWorkflowProcess<E, C, TaskName>,
) => {
  const events = await currentEvents(command);
  const allEvents = [...decider.computeNewEvents(events, command)];
  let newViewState = view.initialState;
  let workflowState = workflow.initialState;

  // Process events and recursively handle workflow-generated commands
  const eventsToProcess = [...allEvents];
  while (eventsToProcess.length > 0) {
    const event = eventsToProcess.shift()!;

    // Update view state
    const stateFromEvent = await currentViewState(event);
    newViewState = view.evolve(stateFromEvent, event);

    // Process event through workflow to generate orchestration commands
    const workflowEvents = workflow.decide(event, workflowState);
    for (const workflowEvent of workflowEvents) {
      workflowState = workflow.evolve(workflowState, workflowEvent);
      const commands = workflow.react(workflowState, workflowEvent);

      // Recursively process workflow commands through the decider
      for (const cmd of commands) {
        const cmdEvents = await currentEvents(cmd);
        // Include both historical events and events produced in this execution
        const allHistoricalEvents = [...cmdEvents, ...allEvents];
        const newEventsFromWorkflow = decider.computeNewEvents(
          allHistoricalEvents,
          cmd,
        );
        allEvents.push(...newEventsFromWorkflow);
        eventsToProcess.push(...newEventsFromWorkflow);
      }
    }
  }

  return { newEvents: allEvents, newViewState };
};

/**
 * Domain-specific command handler for restaurant and order operations with workflow orchestration
 *
 * @remarks
 * This is a specialized version of {@link handleCommandGeneric} configured for the
 * restaurant/order domain. It uses the combined domain deciders, views, and workflow to handle
 * all restaurant and order commands with cross-aggregate orchestration.
 *
 * @param command - The command to handle (RestaurantCommand or OrderCommand)
 * @param currentEvents - Async function that fetches the event history for the command
 * @param currentViewState - Async function that retrieves the view state for a specific event
 *
 * @returns Promise resolving to an object containing:
 * - `newEvents`: All events produced (including those from recursively processed workflow commands)
 * - `newViewState`: The updated view state after sequentially projecting all events
 *
 * @example
 * ```ts
 * const result = await handleCommand(
 *   { kind: "PlaceOrderCommand", id: "r1", orderId: "o1", menuItems: [...] },
 *   async (cmd) => await eventStore.getEvents(cmd.id),
 *   async (evt) => await viewStore.getStateForEvent(evt)
 * );
 * // result.newEvents: [RestaurantOrderPlacedEvent, OrderCreatedEvent]
 * // result.newViewState: [{ restaurantId: "r1", ... }, { orderId: "o1", ... }]
 * // Workflow automatically triggered CreateOrderCommand which produced OrderCreatedEvent
 * ```
 */
export const handleCommand = (
  command: Command,
  currentEvents: (cmd: Command) => Promise<readonly Event[]>,
  currentViewState: (evt: Event) => Promise<
    readonly [RestaurantView | null, OrderView | null]
  >,
) => {
  return handleCommandGeneric<
    Command,
    readonly [Restaurant | null, Order | null],
    Event,
    readonly [RestaurantView | null, OrderView | null],
    OrderTaskName
  >(
    command,
    currentEvents,
    currentViewState,
    all_domain_deciders,
    all_domain_views,
    restaurantOrderWorkflow,
  );
};
